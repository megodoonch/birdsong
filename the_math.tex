\documentclass[12pt]{article}
\usepackage[pdftex]{graphicx}

\usepackage{qtree}


\usepackage{xspace}

\usepackage{setspace} 
\usepackage{float}

\usepackage{stmaryrd}
\usepackage{mathptmx}% http://ctan.org/pkg/mathptmx
\usepackage{times}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{amssymb}

\theoremstyle{definition}
\newtheorem{definition}{Definition}[section]
\newtheorem{lemma}{Lemma}[section]
\newtheorem{thm}{Theorem}[section]


\usepackage{natbib}

\title{The math of the \textsc{cath}}
\author{Meaghan ``geitje'' Fowlie and Floris ``konijntje'' van Vugt}


\begin{document}

\maketitle

\section{Definitions}



%\newcommand\STATES{\mathcal{S}}
\newcommand\STATES{\ensuremath{\mathbb{S}}\xspace}
%\newcommand\OPS{\mathcal{O}}
\newcommand\OPS{\ensuremath{\mathbb{O}}\xspace}
%\newcommand\BIGR{\mathcal{B}}
\newcommand\BIGR{\ensuremath{\mathbb{B}}\xspace}
\newcommand\FSA{\textsc{FSA}\xspace}
%\newcommand\PARSES{\mathcal{P}}
\newcommand\PARSES{\ensuremath{\mathbb{P}}}
\newcommand\SC{\text{\textsc{sc}}}
\newcommand\TC{\text{\textsc{tc}}}
\newcommand\UC{\text{\textsc{uc}}}
\newcommand\BC{\text{\textsc{bc}}}
\newcommand\N{\ensuremath{\mathbb{N}}}
\newcommand\sg{\ensuremath{\Sigma}\xspace}
\newcommand\la{\ensuremath{\langle}\xspace}
\newcommand\ra{\ensuremath{\rangle}\xspace}
\newcommand\arr{\ensuremath{\rightarrow}\xspace}
\newcommand\emp{\ensuremath{\epsilon}\xspace}

\newcommand\op{\text{\textsl{op}}\xspace}
\newcommand\mg{\text{\textsl{mg}}\xspace}
\newcommand\cp{\text{\textsl{copy}}\xspace}
\newcommand\cl{\text{\textsl{clear}}\xspace}
\newcommand\ed{\text{\textsl{end}}\xspace}
\newcommand\start{\text{\textsl{start}}\xspace}

\newcommand\expr{\text{\textsl{expr}}\xspace}
\newcommand\Lex{\text{\textsl{Lex}}\xspace}
\newcommand\fea[1]{\text{\texttt{#1}}\xspace}
\newcommand\LBOUND{\ensuremath{\rtimes}}
\newcommand\RBOUND{\ensuremath{\ltimes}}
\newcommand\OURG{\text{\textsc{cath}}\xspace}


\newcommand\llb{\ensuremath{\llbracket}}
\newcommand\rrb{\ensuremath{\rrbracket}}

\newcommand\IF{\text{ if }\xspace}
\newcommand\der{\leftarrow}
%\newcommand\der{\text{:-}}


We define a deterministic finite state automaton over operations and a Markov chain over the alphabet. these two components make up the grammar. \\

\noindent\textbf{Notation} the size of a set or sequence $A$ is notated $|A|$ or $\#A$. The \textit{i}th member of a sequence $A$ is notated $A(i)$, the last member $A(-1)$, and all but the first $A(1:)$. $\emp$ is the empty sequence.


\subsection{The Grammar}
\label{sec:grammar}



\begin{definition}[Deterministic Finite State Automaton]
  A deterministic finite state automaton (DFSA) is a five-tuple 
\[\la \sg, Q, q_0, F, \delta  \ra  \]
where:

\noindent $\sg$ is an alphabet\\
$Q$ is a finite set (\textit{states})\\
$q_0\in Q$ is the designated \textit{start state}\\
$F\subseteq Q$ is the set of \textit{final states}\\
$\delta: Q\times \sg \arr Q$ is the \textit{transition function} 

A string $s\in\sg^*$ is accepted/generated by a DFSA $A$ iff
$\exists \mathbf{q} \in Q_A^*$ such that $\mathbf{q}(0)=q_0$, $\mathbf{q}(-1)\in F_A$, and $\forall i<|s|$, $\delta(\mathbf{q}(i),s(i))=\mathbf{q}(i+1)$
\label{def:dfsa}
\end{definition}

\begin{definition}
  We say a triple $(q,e,q')$ where $q,q'\in Q$ and $e\in\sg$ is a \textit{transition} of an
  FSA iff $\delta(q,e)=q'$.
\end{definition}

We define a grammar which generates a language \textit{surface strings} over an alphabet \sg by application of operations $\OPS=\{\mg,\cl,\cp,\ed\}$. The choice of operation is governed by a DFSA in which the operations are the emissions of transitions.

In our operations FSA \OPS, the set of all possible states is \STATES=\{S,NotCL,CL$_S$,CL,F\} and the alphabet is the set of all operations is $O=\{\mg,\cl,\cp,\ed\}$. The bigram set or transition set, is $\BIGR\subseteq\sg^*$.


\begin{definition}[Operations FSA]
  The operations FSA is a deterministic finite state automaton over states \STATES and alphabet \OPS.
\end{definition}

\begin{definition}[Transition Probabilities]
   
  A probability assignment $\phi$ is a function from transitions of the operations FSA to [0,1] such that

$$\forall q\in \STATES,~~\sum_{e\in\OPS,q'\in \STATES} \phi(q,e,q') = 1 $$

\end{definition}

\begin{definition}[Markov Chain]
  A Markov chain is a 4-tuple $\la \sg, S, B, \phi  \ra $ where 

\sg  is a finite alphabet of symbols, 

$S\subseteq \sg$ is a set of start categories,
 
$B\subseteq \sg\times\sg$ is a set of transitions between members of \sg, and

$\phi: \sg \times \sg \arr [0,1]$ is a probability distribution over transitions such that

$$\forall a\in \sg,~~\sum_{b\in\sg} \phi(a,b) = 1 $$


A sequence $s$ is accepted/generated by the chain iff $s$ is a sequence of alphabet items such that $s(0) \in S$ and $\forall i<|s|$, $\phi(s(i),s(i+1))>0$ 

\end{definition}

\begin{definition}[route]
  A \emph{route} is a route through the $\FSA$ of say $n$ steps, defined as a tuple $(Q,E)$ where $Q$ is the sequence of states visited, i.e.
%  $Q=\la q_i\in\STATES|i<n\ra$, and $E$ is the sequence of emissions.
 $E=\la e_i\in\OPS|i<n-1\ra$ such that $\forall i<n,~ \delta(q_i,e_i)=q_{i+1}$.

\end{definition}

  I think we need a homomorphism of the sort in Koller's paper to define the relationship between the operations and the surface strings?


\begin{definition}[\OURG]
  \OURG = \la \OPS,\BIGR\ra  where

  $\OPS = \la \{\mg,\cp,\cl,\ed\}, \{S,NotCL,CL_S,CL,F\}, S, \{F\}, \phi_\OPS\ra$ is the DFSA given in Figure \ref{fig:ops}

  $\BIGR = \la \sg\cup\{{\LBOUND}\}, \{\LBOUND\}, B, \phi_\BIGR \ra$ is a Markov Chain  for some alphabet \sg and a left boundary marker \LBOUND.
  
\end{definition}


\begin{figure}[H]
  \centering
  \includegraphics[width=5in]{ops.png}
  \caption{\OPS}
  \label{fig:ops}
\end{figure}


\begin{definition}[Derivation of \OURG]
  A \textit{derivation} of \OURG is a pair (ops,bis) where $ops\in O^*$ and $bis\in\sg^*$
\end{definition}

\begin{thm}
  A derivation (ops,bis) is valid iff:

  \begin{enumerate}
  \item $|bis|=|ops\restriction\mg| $
  \item ops[0]=\mg
  \item ops[-1]=\ed
  \item $(ops\restriction \{\cp,cl\})[-1]\neq\cl$
  \item $(ops\restriction \{\cp,cl\})$ has no contiguous subsequence \cl \cl
\end{enumerate}

\end{thm}



\begin{definition}[Derivation Tree grammar]
  The derivation tree grammar for \OURG is defined by the following CFG. Note that this overgenerates, in that there are dts for invalid derivations among the parse trees.
  \begin{itemize}
  \item \cp \arr \cp $|$ \mg
  \item \cl \arr \cp $|$ \mg
  \item \ed \arr \cp $|$ \mg
  \item \mg \arr \op a ~~~~~~ $\forall \op\in O\cup\{\start\}, \forall a\in\sg$
  \end{itemize}

  The set of parse trees for this grammar is DT.
  
\end{definition}


\begin{definition}[Derivation tree of \OURG]
  The derivation tree for a derivation (ops,bis) is defined by the function $D:O^* \times \sg^* \times DT \arr (O^* \times \sg^* \times DT) \cup DT$ as follows:\\

  $D(ops,bis,t)=  
  \begin{cases}
    t & \text{ if } ops=bis=\emp\\
    D(ops(1:),bis(1:),\mg(t,bis(0))) & \text{ if } ops(0)=\mg ~\&~ bis\neq\emp\\
    D(ops(1:),bis,\op(t)) & \text{ if } ops(0)\neq\mg\\
    \text{undefined} & \text{ otherwise}
  \end{cases}
  $
  
  We say t is the derivation tree for the derivation (ops,bis) iff D(ops,bis,\start) = t.
\end{definition}

At this point we just need to interpret t as string-pair operations, but I will add an intermediate step to ease our proof that \OURG is context-sensitive.

We define a tree homomorphism from DT to a set of string derivation trees in

\begin{definition}[string derivation trees (ST)]
  The parse trees of this grammar form ST.\\
  
\noindent  \cp \arr \cp $|$ $\bullet$\\
  \cl \arr \cp $|$ $\bullet$\\
  \ed \arr \cp $|$ $\bullet$\\
  $\bullet$ \arr \op a ~~~~ $\forall \op\in \{\bullet,\cp,\cl,(\emp,\emp)\}, \forall a\in\sg$
\end{definition}


\begin{definition}[Tree homomorphism for ST ($h_s$)]

  For $t\in DT$, 
  
  $
  h_s(t) =
  \begin{cases}
    (\emp,\emp) & \text{ if } t = \start\\
    t & \text{ if } t\in\sg\\
    \op(h_s(t')) & \text{ if } \exists \op \in \{\cp,\cl,\ed\}, \exists t'\in DT (t=\op(t'))\\
    \bullet(h_s(t'), h_s(a)) & \text{ if } \exists t'\in DT \exists a\in\sg (t=\mg(t',a))\\
  \end{cases}
  $
\end{definition}


\begin{definition}[String pair algebra]
  A string pair algegra is an algebra with signature $\la (\sg^*\times\sg^*)\cup\{\sg^*\},\bullet,\cp,\cl,\ed\ra$
  
  If $t\in ST$, we define its interpretation into the string pair algebra as follows:

   $
  \llb t \rrb_s =
  \begin{cases}
    t & \text{ if } t = t()\\
    \llb\op\rrb(s,b)(\llb t'\rrb) & \text{ if } \exists \op \in \{\cp,\cl,\ed\}, \exists t'\in ST (t=\op(t'))\\
    \llb\bullet\rrb(\llb t'\rrb), \llb a\rrb) & \text{ if } \exists t'\in ST \exists a\in\sg (t=\mg(t',a))\\
  \end{cases}
  $

  where the operations are interpreted as the following functions in the algebra:
  
\noindent  $\llb\bullet((s,b),a)\rrb_s = (sa,ba)$\\  
  $\llb\cp((s,b))\rrb_s = (sb,bb)$\\
  $\llb\cl((s,b))\rrb_s = (s,\emp)$\\
  $\llb\ed((s,b))\rrb_s = s$\\

  
\end{definition}


\textbf{Example:}  let d = (\ed \cp \mg \mg, a b) be a derivation in \OURG.

  D(d) = \Tree[.\ed~ [.\cp~ [.\mg~ [.\mg~ \start~ a ] b ]]]\\\\

  $h_s(D(d))$ = \Tree[.\ed~ [.\cp~ [.$\bullet$ [.$\bullet$ (\emp,\emp) a ] b ]]]

  $\llb h_s(D(d)) \rrb_s = abab$\\
  
In full:
  
  \begin{align*}
    \llb h_s(D(d)) \rrb_s & = \llb \ed(\cp(\bullet(\bullet((\emp,\emp),~a),~b))) \rrb \\
    & = \llb \ed\rrb (\llb\cp(\bullet(\bullet((\emp,\emp),~a),~b)) \rrb)\\
    &  = \llb \ed\rrb(\llb\cp\rrb(\llb\bullet(\bullet((\emp,\emp),~a),~b)\rrb))\\
    &  = \llb \ed\rrb(\llb\cp\rrb(\llb\bullet\rrb(\llb\bullet((\emp,\emp),a)\rrb,~b)))\\
    &  = \llb \ed\rrb(\llb\cp\rrb(\llb\bullet\rrb(\llb\bullet\rrb((\emp,\emp),~a),~b)))\\
    &  = \llb \ed\rrb(\llb\cp\rrb(\llb\bullet\rrb((a,a),~b)))\\
    &  = \llb \ed\rrb(\llb\cp\rrb((ab,ab)))\\
    &  = \llb \ed\rrb((abab,abab))\\
    & = abab
  \end{align*}


\subsection{PMCFG}
\label{sec:pmcfg}

Why did we bother with both $h_s$ and $\llb\cdot\rrb_s$ instead of interpreting the derivation tree directly in the string algebra? In order to facilitate the proof that \OURG is mildly context sensitive; specifically that it is weakly equivalent to a parallel multiple context free grammar. We define a second tree homomorphism $h_p$ into the derivations of a PMCFG and show that the homomorphism is in fact an isomorphism.

\begin{definition}[PMCFG $P$]

  Let $a,c$ be metavariables over \sg. The PMCFG P(g) for (\OPS,\BIGR) for some \OURG g is defined as follows:

  $P(g)=\la \{C^{(2)},T^{(3)},S^{(1)},W^{(1)}\}, \sg^{(0)}, S, V=\{x,y,z\}, R \ra$

Where the productions rules R given below. For our convenience, each rule is given a (not necessarily unique) name; this is used in the proof below.\\

These are called Horn clauses.

$R=  \begin{array}{r | r c l l}
       \text{name} & rules\\
       \hline
       \cl & C(s,x) &\der& T(s,b,x)\\
       \cp & T(sb,bb,x) &\der& T(s,b,x)\\
       \mg & T(sa,ba,a) &\der& T(s,b,c), a & \forall (c,a)\in\BIGR\\
       \mg & T(sa,a,a) &\der& C(s,c), a & \forall (c,a)\in\BIGR\\
       \ed & S(s) &\der& T(s,b,x)\\
       \text{\textsl{start}} & C(\emp,\LBOUND) &\der&\\
                   & W(a) &\der& &\forall a\in\sg\\
       
     \end{array}$

     The set of parse trees for this grammar is PT.
     
 \end{definition}



 \textbf{Example:} abab

 \Tree[.S(abab) [.T(abab,abab,b) [.T(ab,ab,b) [.T(a,a,a) C(\emp,\LBOUND) W(a) ] W(b) ]]]   

 \textbf{Example:} abb

 \Tree[.S(abab) [.T(abb,abb,b) [.T(ab,b,b) [.C(a,a) [.T(a,a,a) C(\emp,\LBOUND) W(a) ] ] W(b) ]]]   \\
 

 \begin{definition}[derivation tree of an MCFG \citep{makoto-kanazawa-lecture-notes-2016}]
   In order to get derivation trees of an MCFG that are defined over a finite alphabet, we label our internal nodes with the rules themselves. For each node p, if p is labelled $B(\alpha_1,...,\alpha_n)\der B_1(\mathbf{x_{11},...x_{1r_1}}),\dots,B_n(\mathbf{x_{n1},...x_{nr_n}})$
   then p has n daughters, and $\forall i\leq n$, the $i$th daughter is $B_i(t_1,\dots, t_{r_i})$, $t$s trees.
 \end{definition}


 
 \begin{definition}
   The derived string of a derivation tree $B(\alpha_1,...,\alpha_n)\der daughters (t_1,\dots t_n)$  is calculates as follows: For every $t_i$, if $derstr(t_i) = (s_{i1},\dots,s_{ir_i})$ then $derstr(t)=(\alpha_1,\dots,\alpha_n)\sigma$, where $\sigma$ is the substitution $[\mathbf{x}_{ij}\der w_{ij}]$
 \end{definition}
 
We can simplify our rule names as follows, making the trees easier to read, and making the relationship between the MCFG dt and the \OURG dt clear:

$R=  \begin{array}{r | r c l l}
       \text{name} & rules\\
       \hline
       \cl & C(s,x) &\der& T(s,b,x)\\
       \cp & T(sb,bb,x) &\der& T(s,b,x)\\
       \mg_{Tca} & T(sa,ba,a) &\der& T(s,b,c), a & \forall (c,a)\in\BIGR\\
       \mg_{Cca} & T(sa,a,a) &\der& C(s,c), a & \forall (c,a)\in\BIGR\\
       \ed & S(s) &\der& T(s,b,x)\\
       \text{\textsl{start}} & C(\emp,\LBOUND) &\der&\\
       & W(a) &\der & &\forall a\in\sg\\
     \end{array}$\\

 \textbf{Example:} abab parse tree, derivation tree, more readable derivation tree

 {\small
 \Tree[.S(abab) [.T(abab,abab,b) [.T(ab,ab,b) [.T(a,a,a) C(\emp,\LBOUND) W(a) ] W(b) ]]]   
 \Tree[.{S(\textbf{x})$\der$ T(\textbf{x,y,z})} [.{T(\textbf{xy,yy,z})$\der$ T(\textbf{x,y,z})} [.{T(\textbf{x}b,\textbf{y}b,b)$\der$ T(\textbf{x,y},a), W(a)} [.{T(\textbf{x}a,a,a)$\der$ C(x,\LBOUND),W(a)} C(\emp,\LBOUND) W(a) ] {W(b)} ]]]   
 \Tree[.\ed~ [.\cp~ [.$\mg_{Tab}$ [.$\mg_{C\LBOUND a}$ {C(\emp,\LBOUND)} W(a) ] W(b) ]]]   
}\\\\

We define a tree transducer $h_p$ from the derivation trees of \OURG DT to the derivation trees of the equivalent MCFG PDT as follows:

\begin{definition}[Tree transducer from DT to PDT]

  $T=\la Q, O\cup\sg, PO\cup\sg, Q_f, \delta \ra$
  
  Where PO is the set of rule names in table \ref{tab:mcfg-names}, Q is the set of states defiuned below, $Q_F = \{q_f\}$ and $\delta$ is the transition function defined as follows:

  $\begin{array}[H]{r c l l}
     \delta(a) & = & q_a(W(a)) & \forall a\in\sg\\
     \delta(\start) & = & q_{C\LBOUND}(C(\emp,\LBOUND))\\
     \delta(\ed(q(t))) & = & q_f(\ed(t)) & \forall q\in Q\\
     \delta(\cp(q(t)) & = & q(\cp(t)) & \forall q\in Q\\
     \delta(\cl(q(t)) & = & q_{Cx}(\cl(t)) & \IF \exists x\in\sg (q=q_{Tx})\\
     \delta(\mg(q_1(t_1),q_2(t_2))) & = & q_{Ty}(\mg_{Zxy}(t_1,t_2)) & \IF \exists Z\in\{T,C\} \exists x,y\in\sg (q_1=q_{Zx} \& q_2=q_{Zy})
  \end{array}
$\\

$Q=\{q_x | x\in\sg\}\cup \{q_{Zx} | x\in\sg ~\&~ Z\in\{T,C\}\}\cup\{q_f\} $
  
\end{definition}

Since we rely on the states to get the right \mg functions, this is not a tree homomorphism, since a tree homomorphism is a tree transducer with only one state \citep{schieber-2004-TAG+}. I don't think this is a problem though because T generates derivation trees isomorphic to their preimage.

Example:

\Tree[.\ed~ [.\cp~ [.\mg~ [.\mg~ \start~ a ] b ]]] $\Rightarrow$
\Tree[.\ed~ [.\cp~ [.\mg~ [.\mg~ [.$q_{C\LBOUND}$ C(\emp,\LBOUND) ] [.$q_a$ W(a) ] ] [.$q_b$ W(b) ]]]] $\Rightarrow$
\Tree[.\ed~ [.\cp~ [.\mg~ [.$q_{Ta}$ [.$\mg_{C\LBOUND a}$ C(\emp,\LBOUND)   W(a)  ]] [.$q_b$ W(b) ]]]]  $\Rightarrow$
\Tree[.\ed~ [.\cp~ [.$q_{Tb}$ [.$\mg_{Tab}$ [.$\mg_{C\LBOUND a}$ C(\emp,\LBOUND)   W(a)  ] W(b) ]]]]
$\Rightarrow$
\Tree[.\ed~ [.$q_{Tb}$ [.\cp~  [.$\mg_{Tab}$ [.$\mg_{C\LBOUND a}$ C(\emp,\LBOUND)   W(a)  ] W(b) ]]]]
$\Rightarrow$
\Tree[.$q_{f}$ [.\ed~  [.\cp~  [.$\mg_{Tab}$ [.$\mg_{C\LBOUND a}$ C(\emp,\LBOUND)   W(a)  ] W(b) ]]]]\\\\

Note that this transducer doesn't enforce all the rules of the grammar. If there are bad derivation trees they'll be interpreted as uninterpretable dts in the PMCFG. I think right now I havne't distinguished the co-domain from the yield. Haffoo do that.


% \begin{definition}
%   $h_p(t) =\\
%   \begin{cases}
%     C(\emp,\LBOUND) & \IF t=\start\\
%     t & \IF t\in\sg\\
%     S(x)((T(x,y,z)(h_p(t''))) &\IF \exists t'\in DT (t=\ed(t')) ~\&~ \exists x,y,z\in V ~\&\\
%     &~~~~~\exists t''\in PT~ (h_p(t') = T(x,y,z)(t'')))\\
%     C(x,z)((T(x,y,z)(h_p(t''))) &\IF \exists t'\in DT (t=\cl(t')) ~\&~ \exists x,y,z\in V ~\&\\
%     &~~~~~\exists t''\in PT~ (h_p(t') = T(x,y,z)(t'')))\\
%     T(xy,yy,z)((T(x,y,z)(h_p(t''))) &\IF \exists t'\in DT (t=\cp(t')) ~\&~ \exists x,y,z\in V ~\&\\
%     &~~~~~\exists t''\in PT~ (h_p(t') = T(x,y,z)(t'')))\\
%     T(xa,ya,a)((T(x,y,c)(h_p(t'')), a) &\IF \exists t'\in DT \exists a\in\sg (t=\mg(t'),a) ~\&~ \exists x,y,z\in V ~\&\\
%     &~~~~~\exists t''\in PT~ (h_p(t') = T(x,y,z)(t'')))\\
%     T(xa,ya,a)((C(x,c)(h_p(t'')), a) &\IF \exists t'\in DT \exists a\in\sg (t=\mg(t'),a) ~\&~ \exists x,z\in V ~\&\\
%     &~~~~~\exists t''\in PT~ (h_p(t') = C(x,z)(t'')))\\

%   \end{cases}
% $
% \end{definition}


% OK, I think this is not a tree homomorphism because the internal node labels do not form a finite set. However, it should be easy to see that the trees are isomorphic modulo labelling. Which should give us homomorphism anyway, assuming $h_p$ is defined for every DT. Is it rather that you can't have a tree homomorphism between a tree language over a finite alphabet and one over an infinite alphabet?






%Probably then everything is fine anyway. We want to show that the two tree languages are isomorphic:

\begin{thm}[$DT \simeq PT$]
  The set of derivation trees for a given \OURG is isomorphic to the set of derivation trees of $P(\OURG)$.
\end{thm}

\begin{proof}
  We take the homomorphism induced by the transducer? Show it's an iso?
  
\end{proof}







\end{document}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
