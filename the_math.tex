\documentclass[12pt]{article}
\usepackage[pdftex]{graphicx}

\usepackage{qtree}


\usepackage{xspace}

\usepackage{setspace} 
\usepackage{float}

\usepackage{stmaryrd}
\usepackage{mathptmx}% http://ctan.org/pkg/mathptmx
\usepackage{times}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{amssymb}

\theoremstyle{definition}
\newtheorem{definition}{Definition}[section]
\newtheorem{lemma}{Lemma}[section]
\newtheorem{thm}{Theorem}[section]


\usepackage{natbib}

\title{The math of the \textsc{cath}}
\author{Meaghan ``geitje'' Fowlie and Floris ``konijntje'' van Vugt}


\begin{document}

\maketitle

\section{Definitions}



%\newcommand\STATES{\mathcal{S}}
\newcommand\STATES{\ensuremath{\mathbb{S}}\xspace}
%\newcommand\OPS{\mathcal{O}}
\newcommand\OPS{\ensuremath{\mathbb{O}}\xspace}
%\newcommand\BIGR{\mathcal{B}}
\newcommand\BIGR{\ensuremath{\mathbb{B}}\xspace}
\newcommand\FSA{\textsc{FSA}\xspace}
%\newcommand\PARSES{\mathcal{P}}
\newcommand\PARSES{\ensuremath{\mathbb{P}}}
\newcommand\SC{\text{\textsc{sc}}}
\newcommand\TC{\text{\textsc{tc}}}
\newcommand\UC{\text{\textsc{uc}}}
\newcommand\BC{\text{\textsc{bc}}}
\newcommand\N{\ensuremath{\mathbb{N}}}
\newcommand\sg{\ensuremath{\Sigma}\xspace}
\newcommand\la{\ensuremath{\langle}\xspace}
\newcommand\ra{\ensuremath{\rangle}\xspace}
\newcommand\arr{\ensuremath{\rightarrow}\xspace}
\newcommand\emp{\ensuremath{\epsilon}\xspace}

\newcommand\op{\text{\textsl{op}}\xspace}
\newcommand\mg{\text{\textsl{mg}}\xspace}
\newcommand\cp{\text{\textsl{copy}}\xspace}
\newcommand\cl{\text{\textsl{clear}}\xspace}
\newcommand\ed{\text{\textsl{end}}\xspace}
\newcommand\start{\text{\textsl{start}}\xspace}


\newcommand\expr{\text{\textsl{expr}}\xspace}
\newcommand\Lex{\text{\textsl{Lex}}\xspace}
\newcommand\fea[1]{\text{\texttt{#1}}\xspace}
\newcommand\LBOUND{\ensuremath{\rtimes}}
\newcommand\RBOUND{\ensuremath{\ltimes}}
\newcommand\OURG{\text{\textsc{cath}}\xspace}


\newcommand\llb{\ensuremath{\llbracket}}
\newcommand\rrb{\ensuremath{\rrbracket}}

\newcommand\IF{\text{ if }\xspace}
\newcommand\der{\leftarrow}
%\newcommand\der{\text{:-}}


We define a deterministic finite state automaton over operations and a Markov chain over the alphabet. these two components make up the grammar. \\

\noindent\textbf{Notation} the size of a set or sequence $A$ is notated $|A|$ or $\#A$. The \textit{i}th member of a sequence $A$ is notated $A(i)$, the last member $A(-1)$, and all but the first $A(1:)$. $\emp$ is the empty sequence.


\subsection{The Grammar}
\label{sec:grammar}



\begin{definition}[Deterministic Finite State Automaton]
  A deterministic finite state automaton (DFSA) is a five-tuple 
\[\la \sg, Q, q_0, F, \delta  \ra  \]
where:

\noindent $\sg$ is an alphabet\\
$Q$ is a finite set (\textit{states})\\
$q_0\in Q$ is the designated \textit{start state}\\
$F\subseteq Q$ is the set of \textit{final states}\\
$\delta: Q\times \sg \arr Q$ is the \textit{transition function} 

A string $s\in\sg^*$ is accepted/generated by a DFSA $A$ iff
$\exists \mathbf{q} \in Q_A^*$ such that $\mathbf{q}(0)=q_0$, $\mathbf{q}(-1)\in F_A$, and $\forall i<|s|$, $\delta(\mathbf{q}(i),s(i))=\mathbf{q}(i+1)$
\label{def:dfsa}
\end{definition}

\begin{definition}
  We say a triple $(q,e,q')$ where $q,q'\in Q$ and $e\in\sg$ is a \textit{transition} of an
  FSA iff $\delta(q,e)=q'$.
\end{definition}

We define a grammar which generates a language \textit{surface strings} over an alphabet \sg by application of operations $\OPS=\{\mg,\cl,\cp,\ed\}$. The choice of operation is governed by a DFSA in which the operations are the emissions of transitions.

In our operations FSA \OPS, the set of all possible states is \STATES=\{S,NotCL,CL$_S$,CL,F\} and the alphabet is the set of all operations is $O=\{\mg,\cl,\cp,\ed\}$. The bigram set or transition set, is $\BIGR\subseteq\sg^*$.


\begin{definition}[Operations FSA]
  The operations FSA is a deterministic finite state automaton over states \STATES and alphabet \OPS.
\end{definition}

\begin{definition}[Transition Probabilities]
   
  A probability assignment $\phi$ is a function from transitions of the operations FSA to [0,1] such that

$$\forall q\in \STATES,~~\sum_{e\in\OPS,q'\in \STATES} \phi(q,e,q') = 1 $$

\end{definition}

\begin{definition}[Markov Chain]
  A Markov chain is a 4-tuple $\la \sg, S, B, \phi  \ra $ where 

\sg  is a finite alphabet of symbols, 

$S\subseteq \sg$ is a set of start categories,
 
$B\subseteq \sg\times\sg$ is a set of transitions between members of \sg, and

$\phi: \sg \times \sg \arr [0,1]$ is a probability distribution over transitions such that

$$\forall a\in \sg,~~\sum_{b\in\sg} \phi(a,b) = 1 $$


A sequence $s$ is accepted/generated by the chain iff $s$ is a sequence of alphabet items such that $s(0) \in S$ and $\forall i<|s|$, $\phi(s(i),s(i+1))>0$ 

\end{definition}

\begin{definition}[route]
  A \emph{route} is a route through the $\FSA$ of say $n$ steps, defined as a tuple $(Q,E)$ where $Q$ is the sequence of states visited, i.e.
%  $Q=\la q_i\in\STATES|i<n\ra$, and $E$ is the sequence of emissions.
 $E=\la e_i\in\OPS|i<n-1\ra$ such that $\forall i<n,~ \delta(q_i,e_i)=q_{i+1}$.

\end{definition}

 

\begin{definition}[\OURG]
  \OURG = \la \OPS,\BIGR\ra  where

  $\OPS = \la \{\mg,\cp,\cl,\ed\}, \{S,NotCL,CL_S,CL,F\}, S, \{F\}, \phi_\OPS\ra$ is the DFSA given in Figure \ref{fig:ops}

  $\BIGR = \la \sg\cup\{{\LBOUND}\}, \{\LBOUND\}, B, \phi_\BIGR \ra$ is a Markov Chain  for some alphabet \sg and a left boundary marker \LBOUND.
  
\end{definition}


\begin{figure}[H]
  \centering
  \includegraphics[width=5in]{ops.png}
  \caption{\OPS}
  \label{fig:ops}
\end{figure}


\begin{definition}[Derivation of \OURG]
  A \textit{derivation} of a grammar \OURG = \la\OPS,\BIGR\ra is a pair (ops,bis) where $ops\in
  L(\OPS)^*$ and $bis\in L(\BIGR)$, and  $|bis|=|ops\restriction\mg| $
\end{definition}

\begin{thm}
  A derivation (ops,bis) is valid iff:

  \begin{enumerate}
  \item ops[0]=\mg
  \item There is exactly one \ed and it is the last element of ops.
  \item $(ops\restriction \{\cp,cl\})[-1]\neq\cl$
  \item $(ops\restriction \{\cp,cl\})$ has no contiguous subsequence \cl \cl
\end{enumerate}

\label{thm:valid-properties}
\end{thm}



\begin{definition}[Derivation Tree grammar]
  The derivation tree grammar for \OURG is defined by the following CFG. Note that this overgenerates, in that there are dts for invalid derivations among the parse trees.
  \begin{itemize}
  \item \cp \arr \cp $|$ \mg
  \item \cl \arr \cp $|$ \mg
  \item \ed \arr \cp $|$ \mg
  \item \mg \arr \op a ~~~~~~ $\forall \op\in O\cup\{\start\}, \forall a\in\sg$
  \end{itemize}

  The set of parse trees for this grammar is $T_{O\cup\sg\cup\start}$.
  
\end{definition}


\begin{definition}[Derivation trees of \OURG (DT(\OURG))]
  The derivation tree for a derivation (ops,bis) is defined by the function $D:O^* \times \sg^* \times T_{O\cup\sg\cup\start} \arr (O^* \times \sg^* \times T_{O\cup\sg\cup\start}) \cup T_{O\cup\sg\cup\start}$ as follows:\\

  $D(ops,bis,t)=  
  \begin{cases}
    t & \text{ if } ops=bis=\emp\\
    D(ops(1:),bis(1:),\mg(t,bis(0))) & \text{ if } ops(0)=\mg ~\&~ bis\neq\emp\\
    D(ops(1:),bis,\op(t)) & \text{ if } ops(0)\neq\mg\\
    \text{undefined} & \text{ otherwise}
  \end{cases}
  $
  
  We say t is the derivation tree for the derivation (ops,bis) iff D(ops,bis,\start) = t.
\end{definition}

At this point we just need to interpret t as string-pair operations, but I will add an intermediate step to ease our proof that \OURG is context-sensitive.

We define a tree homomorphism from DT to a set of string derivation trees in

\begin{definition}[string derivation trees (ST)]
  The parse trees of this grammar form ST.\\
  
\noindent  \cp \arr \cp $|$ $\bullet$\\
  \cl \arr \cp $|$ $\bullet$\\
  \ed \arr \cp $|$ $\bullet$\\
  $\bullet$ \arr \op a ~~~~ $\forall \op\in \{\bullet,\cp,\cl,(\emp,\emp)\}, \forall a\in\sg$
\end{definition}


\begin{definition}[Tree homomorphism for ST ($h_s$)]

  For $t\in DT$, 
  
  $
  h_s(t) =
  \begin{cases}
    (\emp,\emp) & \text{ if } t = \start\\
    t & \text{ if } t\in\sg\\
    \op(h_s(t')) & \text{ if } \exists \op \in \{\cp,\cl,\ed\}, \exists t'\in DT (t=\op(t'))\\
    \bullet(h_s(t'), h_s(a)) & \text{ if } \exists t'\in DT \exists a\in\sg (t=\mg(t',a))\\
  \end{cases}
  $
\end{definition}


\begin{definition}[\OURG algebra]
  A \OURG algebra is an algebra with signature $\la (\sg^*\times\sg^*)\cup\{\sg^*\},\bullet,\cp,\cl,\ed\ra$
  
  If $t\in ST$, we define its interpretation into the string pair algebra as follows:

   $
  \llb t \rrb_s =
  \begin{cases}
    t & \text{ if } t = t()\\
    \llb\op\rrb(s,b)(\llb t'\rrb) & \text{ if } \exists \op \in \{\cp,\cl,\ed\}, \exists t'\in ST (t=\op(t'))\\
    \llb\bullet\rrb(\llb t'\rrb), \llb a\rrb) & \text{ if } \exists t'\in ST \exists a\in\sg (t=\mg(t',a))\\
  \end{cases}
  $

  where the operations are interpreted as the following functions in the algebra:
  
\noindent  $\llb\bullet((s,b),a)\rrb_s = (sa,ba)$\\  
  $\llb\cp((s,b))\rrb_s = (sb,bb)$\\
  $\llb\cl((s,b))\rrb_s = (s,\emp)$\\
  $\llb\ed((s,b))\rrb_s = s$\\

  
\end{definition}


\textbf{Example:}  let d = (\ed \cp \mg \mg, a b) be a derivation in \OURG.

  D(d) = \Tree[.\ed~ [.\cp~ [.\mg~ [.\mg~ \start~ a ] b ]]]\\\\

  $h_s(D(d))$ = \Tree[.\ed~ [.\cp~ [.$\bullet$ [.$\bullet$ (\emp,\emp) a ] b ]]]

  $\llb h_s(D(d)) \rrb_s = abab$\\
  
In full:
  
  \begin{align*}
    \llb h_s(D(d)) \rrb_s & = \llb \ed(\cp(\bullet(\bullet((\emp,\emp),~a),~b))) \rrb \\
    & = \llb \ed\rrb (\llb\cp(\bullet(\bullet((\emp,\emp),~a),~b)) \rrb)\\
    &  = \llb \ed\rrb(\llb\cp\rrb(\llb\bullet(\bullet((\emp,\emp),~a),~b)\rrb))\\
    &  = \llb \ed\rrb(\llb\cp\rrb(\llb\bullet\rrb(\llb\bullet((\emp,\emp),a)\rrb,~b)))\\
    &  = \llb \ed\rrb(\llb\cp\rrb(\llb\bullet\rrb(\llb\bullet\rrb((\emp,\emp),~a),~b)))\\
    &  = \llb \ed\rrb(\llb\cp\rrb(\llb\bullet\rrb((a,a),~b)))\\
    &  = \llb \ed\rrb(\llb\cp\rrb((ab,ab)))\\
    &  = \llb \ed\rrb((abab,abab))\\
    & = abab
  \end{align*}


\subsection{PMCFG}
\label{sec:pmcfg}

Why did we bother with both $h_s$ and $\llb\cdot\rrb_s$ instead of interpreting the derivation tree directly in the string algebra? In order to facilitate the proof that \OURG is mildly context sensitive; specifically that it is weakly equivalent to a parallel multiple context free grammar. We define a second tree homomorphism $h_p$ into the derivations of a PMCFG and show that the homomorphism is in fact an isomorphism.

\begin{definition}[PMCFG $P$]

  Let $a,c$ be metavariables over \sg. The PMCFG P(g) for (\OPS,\BIGR) for some \OURG g is defined as follows:

  $P(g)=\la \{C^{(2)},T^{(3)},S^{(1)},W^{(1)}\}, \sg^{(0)}, S, V=\{x,y,z\}, R \ra$

Where the productions rules R given below. For our convenience, each rule is given a (not necessarily unique) name; this is used in the proof below.\\

These are called Horn clauses.

$R=  \begin{array}{r | r c l l}
       \text{name} & rules\\
       \hline
       \cl & C(s,x) &\der& T(s,b,x)\\
       \cp & T(sb,bb,x) &\der& T(s,b,x)\\
       \mg & T(sa,ba,a) &\der& T(s,b,c), a & \forall (c,a)\in\BIGR\\
       \mg & T(sa,a,a) &\der& C(s,c), a & \forall (c,a)\in\BIGR\\
       \ed & S(s) &\der& T(s,b,x)\\
       \text{\textsl{start}} & C(\emp,\LBOUND) &\der&\\
                   & W(a) &\der& &\forall a\in\sg\\
       
     \end{array}$

     The set of parse trees for this grammar is PT.
     
 \end{definition}



 \textbf{Example:} abab

 \Tree[.S(abab) [.T(abab,abab,b) [.T(ab,ab,b) [.T(a,a,a) C(\emp,\LBOUND) W(a) ] W(b) ]]]   

 \textbf{Example:} abb

 \Tree[.S(abab) [.T(abb,abb,b) [.T(ab,b,b) [.C(a,a) [.T(a,a,a) C(\emp,\LBOUND) W(a) ] ] W(b) ]]]   \\
 

 \begin{definition}[derivation tree of an MCFG \citep{makoto-kanazawa-lecture-notes-2016}]
   In order to get derivation trees of an MCFG that are defined over a finite alphabet, we label our internal nodes with the rules themselves. For each node p, if p is labelled $B(\alpha_1,...,\alpha_n)\der B_1(\mathbf{x_{11},...x_{1r_1}}),\dots,B_n(\mathbf{x_{n1},...x_{nr_n}})$
   then p has n daughters, and $\forall i\leq n$, the $i$th daughter is $B_i(t_1,\dots, t_{r_i})$, $t$s trees.
 \end{definition}


 
 \begin{definition}
   The derived string of a derivation tree $B(\alpha_1,...,\alpha_n)\der daughters (t_1,\dots t_n)$  is calculates as follows: For every $t_i$, if $derstr(t_i) = (s_{i1},\dots,s_{ir_i})$ then $derstr(t)=(\alpha_1,\dots,\alpha_n)\sigma$, where $\sigma$ is the substitution $[\mathbf{x}_{ij}\der w_{ij}]$
 \end{definition}
 
We can simplify our rule names as follows, making the trees easier to read, and making the relationship between the MCFG dt and the \OURG dt clear:

$R=  \begin{array}{r | r c l l}
       \text{name} & rules\\
       \hline
       \cl & C(s,x) &\der& T(s,b,x)\\
       \cp & T(sb,bb,x) &\der& T(s,b,x)\\
       \mg_{Tca} & T(sa,ba,a) &\der& T(s,b,c), a & \forall (c,a)\in\BIGR\\
       \mg_{Cca} & T(sa,a,a) &\der& C(s,c), a & \forall (c,a)\in\BIGR\\
       \ed & S(s) &\der& T(s,b,x)\\
       \text{\textsl{start}} & C(\emp,\LBOUND) &\der&\\
       & W(a) &\der & &\forall a\in\sg\\
     \end{array}$\\

 \textbf{Example:} abab parse tree, derivation tree, more readable derivation tree

 {\small
 \Tree[.S(abab) [.T(abab,abab,b) [.T(ab,ab,b) [.T(a,a,a) C(\emp,\LBOUND) W(a) ] W(b) ]]]   
 \Tree[.{S(\textbf{x})$\der$ T(\textbf{x,y,z})} [.{T(\textbf{xy,yy,z})$\der$ T(\textbf{x,y,z})} [.{T(\textbf{x}b,\textbf{y}b,b)$\der$ T(\textbf{x,y},a), W(a)} [.{T(\textbf{x}a,a,a)$\der$ C(x,\LBOUND),W(a)} C(\emp,\LBOUND) W(a) ] {W(b)} ]]]   
 \Tree[.\ed~ [.\cp~ [.$\mg_{Tab}$ [.$\mg_{C\LBOUND a}$ {C(\emp,\LBOUND)} W(a) ] W(b) ]]]   
}\\\\

We define a tree transducer $h_p$ from the derivation trees of \OURG DT to the derivation trees of the equivalent MCFG PDT as follows:

\begin{definition}[Tree transducer from DT to PDT]

  $T=\la Q, O\cup\sg, PO\cup\sg, Q_f, \delta \ra$
  
  Where PO is the set of rule names in table \ref{tab:mcfg-names}, Q is the set of states defiuned below, $Q_F = \{q_f\}$ and $\delta$ is the transition function defined as follows:

  $\begin{array}[H]{r c l l}
     \delta(a) & = & q_a(W(a)) & \forall a\in\sg\\
     \delta(\start) & = & q_{C\LBOUND}(C(\emp,\LBOUND))\\
     \delta(\ed(q(t))) & = & q_f(\ed(t)) & \forall q\in Q\\
     \delta(\cp(q(t)) & = & q(\cp(t)) & \forall q\in Q\\
     \delta(\cl(q(t)) & = & q_{Cx}(\cl(t)) & \IF \exists x\in\sg (q=q_{Tx})\\
     \delta(\mg(q_1(t_1),q_2(t_2))) & = & q_{Ty}(\mg_{Zxy}(t_1,t_2)) & \IF \exists Z\in\{T,C\} \exists x,y\in\sg (q_1=q_{Zx} \& q_2=q_{Zy})
  \end{array}
$\\

$Q=\{q_x | x\in\sg\}\cup \{q_{Zx} | x\in\sg ~\&~ Z\in\{T,C\}\}\cup\{q_f\} $
  
\end{definition}

Since we rely on the states to get the right \mg functions, this is not a tree homomorphism, since a tree homomorphism is a tree transducer with only one state \citep{schieber-2004-TAG+}. I don't think this is a problem though because T generates derivation trees isomorphic to their preimage.

Example:

\Tree[.\ed~ [.\cp~ [.\mg~ [.\mg~ \start~ a ] b ]]] $\Rightarrow$
\Tree[.\ed~ [.\cp~ [.\mg~ [.\mg~ [.$q_{C\LBOUND}$ C(\emp,\LBOUND) ] [.$q_a$ W(a) ] ] [.$q_b$ W(b) ]]]] $\Rightarrow$
\Tree[.\ed~ [.\cp~ [.\mg~ [.$q_{Ta}$ [.$\mg_{C\LBOUND a}$ C(\emp,\LBOUND)   W(a)  ]] [.$q_b$ W(b) ]]]]  $\Rightarrow$
\Tree[.\ed~ [.\cp~ [.$q_{Tb}$ [.$\mg_{Tab}$ [.$\mg_{C\LBOUND a}$ C(\emp,\LBOUND)   W(a)  ] W(b) ]]]]
$\Rightarrow$
\Tree[.\ed~ [.$q_{Tb}$ [.\cp~  [.$\mg_{Tab}$ [.$\mg_{C\LBOUND a}$ C(\emp,\LBOUND)   W(a)  ] W(b) ]]]]
$\Rightarrow$
\Tree[.$q_{f}$ [.\ed~  [.\cp~  [.$\mg_{Tab}$ [.$\mg_{C\LBOUND a}$ C(\emp,\LBOUND)   W(a)  ] W(b) ]]]]\\\\

Note that this transducer doesn't enforce all the rules of the grammar. If there are bad derivation trees they'll be interpreted as uninterpretable dts in the PMCFG. I think right now I havne't distinguished the co-domain from the yield. Haffoo do that.


% \begin{definition}
%   $h_p(t) =\\
%   \begin{cases}
%     C(\emp,\LBOUND) & \IF t=\start\\
%     t & \IF t\in\sg\\
%     S(x)((T(x,y,z)(h_p(t''))) &\IF \exists t'\in DT (t=\ed(t')) ~\&~ \exists x,y,z\in V ~\&\\
%     &~~~~~\exists t''\in PT~ (h_p(t') = T(x,y,z)(t'')))\\
%     C(x,z)((T(x,y,z)(h_p(t''))) &\IF \exists t'\in DT (t=\cl(t')) ~\&~ \exists x,y,z\in V ~\&\\
%     &~~~~~\exists t''\in PT~ (h_p(t') = T(x,y,z)(t'')))\\
%     T(xy,yy,z)((T(x,y,z)(h_p(t''))) &\IF \exists t'\in DT (t=\cp(t')) ~\&~ \exists x,y,z\in V ~\&\\
%     &~~~~~\exists t''\in PT~ (h_p(t') = T(x,y,z)(t'')))\\
%     T(xa,ya,a)((T(x,y,c)(h_p(t'')), a) &\IF \exists t'\in DT \exists a\in\sg (t=\mg(t'),a) ~\&~ \exists x,y,z\in V ~\&\\
%     &~~~~~\exists t''\in PT~ (h_p(t') = T(x,y,z)(t'')))\\
%     T(xa,ya,a)((C(x,c)(h_p(t'')), a) &\IF \exists t'\in DT \exists a\in\sg (t=\mg(t'),a) ~\&~ \exists x,z\in V ~\&\\
%     &~~~~~\exists t''\in PT~ (h_p(t') = C(x,z)(t'')))\\

%   \end{cases}
% $
% \end{definition}


% OK, I think this is not a tree homomorphism because the internal node labels do not form a finite set. However, it should be easy to see that the trees are isomorphic modulo labelling. Which should give us homomorphism anyway, assuming $h_p$ is defined for every DT. Is it rather that you can't have a tree homomorphism between a tree language over a finite alphabet and one over an infinite alphabet?






%Probably then everything is fine anyway. We want to show that the two tree languages are isomorphic:

\begin{thm}[$DT \simeq PT$]
  The set of derivation trees for a given \OURG is isomorphic to the
  set of derivation trees of $P(\OURG)$. Moreover, if the isomorphism
  maps $t_1$ to $t_2$, $\llb t_1 \rrb = \llb t_2 \rrb$.
\end{thm}

\begin{proof}


  Let $G$ be a \OURG grammar, and let  $t\in DT(G)$. Let
  $t'=\mathbb{A}(t)$. We show by induction on the tree depth that
  $t\simeq t'$ and $\llb t \rrb = \llb t' \rrb$ . 

  \begin{enumerate}
  \item $t$ has depth 0 or 1 or whatever. Then t=\start or
    $t\in\sg$. If t=\start, $t'=C(\LBOUND,\emp)$ by the definition of
    $\mathbb{A}$. If $t\in\sg$, $t'=W(t)$, so the trees are
    isomorphic. $\llb t \rrb t = \llb W(t) \rrb$
  \item Suppose $t$ has depth $i$ and $\mathbb{A}(t)\simeq t$.
    \begin{description}
    \item[\ed] $\mathbb{A}(\ed(t)) = \ed(\mathbb{A}(t))$ by definition
      of A. 
    \end{description}
  \end{enumerate}
  
  
\end{proof}












\subsection{Alexander's way}
\label{sec:alexanders-way}

\begin{enumerate}
\item Define IRTG with \OURG algebra
\item algebra homomorphism H:'OURG \arr DSTA(G) = Dumb ...? an algegra of simple rules for putting together pairs of sets of strings etc like concatenate and wrap (TAGs)
\item see if IRTGs with DSTA(G) (which requires a non-linear homomorphism) are $\subset$ PMCFG
\item \OURG \arr DT \arr$_{hom}$ \OURG algebra \arr$_{H}$ DSTA(G) $\subset$ L(PMCFG) 
\end{enumerate}

\subsubsection{IRTG}
\label{sec:irtg}

Derivation tree language is regular.\footnote{It occurs to me that
  in a way it makes more sense to make the right daughters of \mg be
  bigrams. Then (a) the automaton is regular and (b) every node is
  labelled by a transition from one of the FSAs.}

Let  $\Gamma = \{\ed^{(1)},\cp^{(1)},\cl^{(1)},\mg^{(2)}\}\cup\sg^{(0)}\cup\{(\emp,\emp)^{(0)}\}$

$DT \subset T(\Gamma)$ (Terms over a ranked alphabet).

For a given \BIGR, given $t\in T(\Gamma)$, $t\in DT$ iff $t$ is accepted by the non-deterministic BUTA $\mathbb{A}$, defined below.

\begin{definition}[Tree automaton for \OURG with bigrams \BIGR ($\mathbb{A_{\BIGR}}$)]
  $\mathbb{A} = \la \Gamma, Q, q_f, \Delta\ra$ where:
  \begin{description}

    
  \item[alphabet] $\Gamma = \{\ed^{(1)},\cp^{(1)},\cl^{(1)},\mg^{(2)}\}\cup\sg^{(0)}\cup\{(\emp,\emp)^{(0)}\}$
    
  \item[states]
    $Q = \left\{
    \begin{array}[H]{c l l}
      & \{\fea{F} , (\LBOUND,\fea{-cl},\fea{-buf})\} & \ed, \start\\
    \cup & \{\fea{=ab} | (a,b)\in\BIGR \} & \text{lexicon}\\
    \cup & \{(\fea{x},\alpha\fea{cl}, \beta\fea{buf}) ~|~  x\in\sg, \alpha,\beta\in\{+,-\}& \text{internal nodes}\\
    \end{array}
\right\}$

  
  \item[Final state] $q_f=\fea{F}$

  
  \item[Transitions]\

    $
  \begin{array}[H]{r c l l}
    \Delta & = & \{\la \ed(\fea{(x,-cl,+buf)}), \fea{F}\ra | \fea{x}\in\sg\} & \ed\\
           & \cup & \{\la b, \fea{=ab}\ra | ((a,b)\in\BIGR)\}& \text{lexical rules}\\
           & \cup & \{\la (\emp,\emp),((\fea{\LBOUND,-cl,-buf)}) \ra\}& \start\\
           & \cup & \{\la \cl(\fea{(x,-cl,+buf)}), (\fea{(x,+cl,-buf)})\ra | \fea{x}\in\sg\} & \cl\\
           & \cup & \{\la \cp((\fea{x},\alpha\fea{cl,+buf})), (\fea{(x,-cl,+buf)}) \ra | \fea{x}\in\sg, \alpha\in\{+,-\} \} & \cp\\
           & \cup & \{\la \mg((\fea{x},\alpha\fea{cl},\beta\fea{buf}), \fea{=xy}),(\fea{y},\alpha\fea{cl},+\fea{buf})\ra | \fea{x,y}\in\sg, \alpha,\beta\in\{+,-\} \} & \mg\\
  \end{array}
  $
\end{description}


  
\end{definition}


Example run:

\Tree[.\ed~ [.\cp~ [.\mg~ [.\mg~ (\emp,\emp) a ] b ]]] 
$\Rightarrow$ 
\Tree[.\ed~ [.\cp~ [.\mg~ [.\mg~ \fea{(\LBOUND,-cl,-buf)} \fea{=\LBOUND a} ] \fea{=ab} ]]] 
$\Rightarrow$ 
\Tree[.\ed~ [.\cp~ [.\mg~ \fea{(a,-cl,+buf)}  \fea{=ab} ]]] 
$\Rightarrow$ 
\Tree[.\ed~ [.\cp~ \fea{(b,-cl,+buf)} ]] 
$\Rightarrow$ 
\Tree[.\ed~ \fea{(b,-cl,+buf)} ] 
$\Rightarrow$ 
\Tree[.\fea{F} ] 

Example 2: nondeterminism can lead to bad state choices. We can't get past the lower \mg node.

\Tree[.\ed~ [.\cp~ [.\mg~ [.\mg~ (\emp,\emp) a ] b ]]] 
$\Rightarrow$ 
\Tree[.\ed~ [.\cp~ [.\mg~ [.\mg~ \fea{(\LBOUND,-cl,-buf)} \fea{=b a} ] \fea{=ab} ]]] 


Example 3: pointless \cl

\Tree[.\ed~ [.\cp~ [.\mg~ (\emp,\emp) a ]]] 
$\Rightarrow$ 
\Tree[.\ed~ [.\cl~ [.\mg~ \fea{(\LBOUND,-cl,-buf)} \fea{=\LBOUND a} ]]] 
$\Rightarrow$ 
\Tree[.\ed~ [.\cl~  \fea{(a,-cl,+buf)} ]] 
$\Rightarrow$ 
\Tree[.\ed~ \fea{(a,+cl,-buf)} ] 

If we show this is in fact a BUTA, and this is in fact the set of derivation trees of \OURG, we've shown the language of derivation trees is regular.

\begin{thm}
  D is 1-1 so D restricted to 
\end{thm}

\begin{thm}[Equivalence of $\mathbb{A}$ and \OURG]
  $L(\mathbb{A}_\BIGR)=\{D(ops,bis,\start) ~|~  (ops,bis)\in L(\OURG)\}$
\end{thm}

\begin{proof}
  \begin{enumerate}
  \item
    $L(\mathbb{A}_\BIGR)\subseteq\{D(ops,bis,\start) ~|~ (ops,bis)\in L(\OURG)\}$: 

    Let $t\in L(\mathbb{A}_\BIGR)$. Every internal node has arity 1 or is \mg. For all transitions in which the first element is $\mg(q_1,q_2)$, $\exists \fea{x,y}\in\sg$ such that  $(q_2=\fea{=xy}$. The only transitions that have such a state as their second element are the lexical rules, so the second daughter of \mg is always from \sg.

    For all transitions in which the first element is \op(q) for some $\op\in O$, q is a triple. Similarly, for the transitions in which the first element is $\mg(q_1,q_2)$, $q_1$ is a triple. The only transitions that have a triple as their second element are those whose first element is \op(q') for some q' or (\start,\fea{(\LBOUND,-cl,-buf)}). Therefore every element on the path down the only and left daughters is an operation or \start. The only transition in which \start is the first element is a lexical rule, and the only lexical transition in which the second element is a triple is (\start,\fea{(\LBOUND,-cl,-buf)}). Therefore, the path down the only and left daughters is a sequence which consists of all the operations in the tree, followed by \start.
    All of the right daughters proper are lexical items.

    $t$ is therefore in the domain of $D^{-1}$. 

    $D^{-1}(x) =
    \begin{cases}
      (ops,bis) & \IF x=(ops,bis,\start)\\
      D^{-1}(\emp,\emp,x) & \IF x\in DT\\
      D^{-1}(\op::ops,bis,t') & \IF x = (\op(t'),ops,bis) \& \op\neq\mg\\
      D^{-1}(\mg::ops,a::bis,t') & \IF x = (\mg(t',a),ops,bis)\\
    \end{cases}
    $
    
    $D^{-1}(t) = (ops,bis)$ for some $ops\in O^*, bis\in\sg^*$:

    $D^{-1}(t) = D^{-1}(\emp,\emp,t))$. We already saw that every subtree of $t$ is of the form $\op(t') (\op\in\{\ed,\cp,\cl\})$, or $\mg(t',a) (a\in\sg)$, or $a\in\sg$, or \start, so  $D^{-1}$ is defined for every subtree. Internal nodes are always labelled with operations, so only operations will be added to ops. Items are added to bis when they occur as the second daughter of \mg, which we have seen is always a lexical item. The one and only left daughter that is a leaf is \start, and when that leaf is reached it is the complete tree, triggering the first case, which returns (ops, bis) without adding \start to the list.

    Now we show $(ops,bis)\in L(\OPS)\times L(\BIGR)$ such that $|ops\restriction\mg|=|bis|$. 

    $|ops\restriction\mg|=|bis|$ is clearly true.

    To show that $ops\in L(\OPS)$, note that the feature configurations $\pm\fea{cl}, \pm\fea{buf}$ correspond to states in \OPS.

    \begin{figure}[H]
      \centering
      \includegraphics[width=4in]{ops.png}
      \caption{\OPS}
      \label{fig:ops}
    \end{figure}
    
    We designed the grammar so that we never copy or clear vacuously. This means that we only copy or clear if there is something in the buffer to copy or clear, and also that we only clear if that act of clearing will define the start of a copy. The former is accomplished by adding a state for when the buffer is empty, from which we can only Merge. The latter is done by adding a new state that we move to when we clear, and from which we can't clear again, nor can we end without first actually copying. When we put these strategies together, we have five states. The start state has no buffer so we can only Merge. From there we go to NotCL, because we have not recently cleared. From here we can do anything, but if we clear, we move to CL$_S$ in which we have cleared (so we can't clear or end) but we also have no buffer so we can't copy either. We Merge and move to CL from which we can't clear or end. If we copy, we move back to NotCL.

In other words, our states are \fea{F} plus the full complement of $\pm$buffer, $\pm$cleared:

\begin{table}[H]
  \centering
  \begin{tabular}[H]{c|c  c}
  & \fea{+clear} &  \fea{-clear}\\
\hline
 \fea{+buffer}& CL  & NotCL\\
 \fea{-buffer}& CL$_S$ & S\\
\end{tabular}
\end{table}
    
ops[0]=\mg because the only $\mathbb{A}$ transitions with \fea{-buf} in their first element are \mg transitions. $\forall o\in L(\OPS)$, o[0] = \mg since that's the only transition out of the start state S.

ops[-1] = \ed because the only $\mathbb{A}$-transitions to F are for
\ed-rooted trees. No other nodes are labelled \ed because there are no
transitions in which \texttt{F} occurs in the first element.

Let $C=ops\restriction \{\cp,\cl\}$

Observe the following:

\begin{enumerate}
\item Only \cl changes \fea{-cl} to \fea{+cl}, meaning the only $\mathbb{A}$-transitions whose first element 
\end{enumerate}

$C[-1] \neq \cl$: the only $\mathbb{A}$-transitions to F are from states \fea{(x,-cl,+buf)}. \fea{-cl} is only changed to \fea{+cl} by transitions for \cl-rooted trees.  \mg-rooted trees always keep their \fea{cl} value, and \cp-rooted trees always transition to a state with \fea{-cl}. We already saw that every tree has a \start node as its only left leaf, and the state for \start has \fea{-cl}. Therefore any sequence of operations in $t$ that ends with a state with \fea{-cl} either has no \cl nodes -- so the original \fea{-cl} is kept --, or all \cl nodes have a later \cp node that changes the state to \fea{-cl}.

$ \not\exists i<|C|$ s.t. $C[i]=C[i+1]=\cl$: the transition rules for \cl-rooted trees are defined only from states with \fea{-cl}. \mg does not change the value of \fea{cl}, and \cl transitions always end with a \fea{+cl} state. Only \cp higher in the tree can change the \fea{+cl} to \fea{-cl}, making a \cl node possible again.

By Theorem \ref{thm:valid-properties} these are the valid derivations.

\item  $\{D(ops,bis,\start) | ops\in L(\OPS),bis\in
    L(\BIGR)\} \subseteq L(\mathbb{A}_\BIGR) $: 

    


\end{enumerate}
\end{proof}

\end{document}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
